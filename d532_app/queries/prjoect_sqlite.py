# -*- coding: utf-8 -*-
"""Prjoect SQLite.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hTSyw0yHpfPr25_G-eDxQdv5GyJU7UNw

# Project Practice Queries

This notebook was created to test the database made for the final DB class project.

The link to this public notebook on Google Colab can be found here:

https://colab.research.google.com/drive/1hTSyw0yHpfPr25_G-eDxQdv5GyJU7UNw?usp=sharing
"""

# Import Relevant Python Libraries
import sqlite3
import pandas as pd

"""### STEP 1. Connect to the database."""

conn = sqlite3.connect('project.db') # Database of joined tables from Kaggle
# conn = sqlite3.connect('new.db') # New Database
c = conn.cursor()

"""### Optional:  Create tables if they don't exist."""

# To create the database, the previous CSV files will be loaded into an SQL database

# read_ratings = pd.read_csv(r'ratings_project.csv')
# read_ratings.to_sql('ratings', conn, if_exists='append', index = False) # Insert the values from the csv file into the table

# read_movieInfo = pd.read_csv(r'movieInfo_project.csv')
# read_movieInfo.to_sql('movieInfo', conn, if_exists='append', index = False) # Insert the values from the csv file into the table

"""### STEP 2. Review tables in your database

Every **SQLite database** has a special table named _sqlite_master_, which is a system created table
"""

c.execute("select * from SQLite_master;") # if you do not need to write sql code on multiple lines, you can use single/double quotes

tables = c.fetchall()

print("Listing tables and indices from main database:")

for table in tables:
        print(table)
        print("Table Name: %s"%(table[2]))

"""##### Let's check the specific column names from the table ratings."""

c.execute("SELECT * FROM ratings")
colnames = c.description

colnames_list = []
for row in colnames:
    colnames_list.append(row[0])

print(colnames_list)

c.execute("SELECT * FROM movieInfo")
colnames = c.description

colnames_list = []
for row in colnames:
    colnames_list.append(row[0])

print(colnames_list)

"""**Optional (Not Implemented)**: Let's check the specific column names from the table ratings."""

# SQLite Query to check for a primary key
c.execute('''
PRAGMA table_info("movieInfo")
;
''')

# Display Result
colnames = c.description
colnames_list = []
for row in colnames:
    colnames_list.append(row[0])

df = pd.DataFrame(c.fetchall(), columns=colnames_list)
df

"""From this query, we can see that there is not a column designated as a Primary key designated.  This is an issue because later queries will rely on replacing values in duplicated rows."""

# Deisgnate a Foreign Key
## Each user should only have a single rating per movie.  So, combined, userId and movieId, make for excellent primary key

# SQLite Query
c.execute('''
SELECT movieInfo
    PRIMARY KEY(userId, movieId)
;
''')

# SQLite Query to check for a primary key
c.execute('''
PRAGMA table_info("movieInfo")
;
''')

# Display Result
colnames = c.description
colnames_list = []
for row in colnames:
    colnames_list.append(row[0])

df = pd.DataFrame(c.fetchall(), columns=colnames_list)
df

"""### Queries

**Query Type 1**: Match Genre & Display Top 5
"""

# Match Genre & Display Top 5

# SQLite Query
c.execute('''
SELECT userId, rating, movie_title, year 
    FROM movieInfo
    WHERE Genres_Horror = 1
    ORDER BY rating DESC LIMIT 5;
''')

# Display Result
colnames = c.description   # gather collumn names from a new query
colnames_list = []
for row in colnames:
    colnames_list.append(row[0])

df = pd.DataFrame(c.fetchall(), columns=colnames_list)
df

# Query for Action

# SQLite Query
c.execute('''
SELECT userId, rating, movie_title, year 
    FROM movieInfo
    WHERE Genres_Action = 1
    ORDER BY rating DESC LIMIT 5;
''')

# Display Result
colnames = c.description   # gather collumn names from a new query
colnames_list = []
for row in colnames:
    colnames_list.append(row[0])

df = pd.DataFrame(c.fetchall(), columns=colnames_list)
df

# Query for Comedy

# SQLite Query
c.execute('''
SELECT userId, rating, movie_title, year 
    FROM movieInfo
    WHERE Genres_Comedy = 1
    ORDER BY rating DESC LIMIT 5;
''')

# Display Result
colnames = c.description   # gather collumn names from a new query
colnames_list = []
for row in colnames:
    colnames_list.append(row[0])

df = pd.DataFrame(c.fetchall(), columns=colnames_list)
df

# Query for Drama

# SQLite Query
c.execute('''
SELECT userId, rating, movie_title, year 
    FROM movieInfo
    WHERE Genres_Drama = 1
    ORDER BY rating DESC LIMIT 5;
''')

# Display Result
colnames = c.description   # gather collumn names from a new query
colnames_list = []
for row in colnames:
    colnames_list.append(row[0])

df = pd.DataFrame(c.fetchall(), columns=colnames_list)
df

"""**Query Type 2**: Pull user rating history"""

# Query and Display user history using userId

# SQLite Query
c.execute('''
SELECT userId, rating, movie_title, year 
    FROM movieInfo
    WHERE userId = 42
    ORDER BY rating DESC, movie_title LIMIT 20;
''')

# Display Result
colnames = c.description
colnames_list = []
for row in colnames:
    colnames_list.append(row[0])

df = pd.DataFrame(c.fetchall(), columns=colnames_list)
df

"""**Query Type 3**: Add Rating"""

# Add a rating by a user

# Must search by Title
# Enter a rating
# Enter a UserId

### This will be done by copying an existing movie row, and then modifying the userId and the rating to match the current user
### Do we care about the timestamp column?

# SQLite Query to create duplicate row
c.execute('''
INSERT INTO movieInfo 
    SELECT * FROM movieInfo WHERE movie_title LIKE '%Temple of Doom%' LIMIT 1
;
''')

# SQLite Query to update duplicate row with the user value and the user rating
c.execute('''
UPDATE movieInfo 
    SET userId = 42, rating = 4.5
    WHERE movie_title LIKE '%Temple of Doom%' LIMIT 1
;
''')

# Display Result
colnames = c.description
colnames_list = []
for row in colnames:
    colnames_list.append(row[0])

df = pd.DataFrame(c.fetchall(), columns=colnames_list)
df

"""# Exit by closing connection to database"""

conn.close